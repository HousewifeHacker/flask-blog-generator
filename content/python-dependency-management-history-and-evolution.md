---
created_at: '2026-02-27T17:32:41.178757'
modified_at: '2026-02-27T19:59:23.897473'
published: true
title: Python Dependency Management -- History and Evolution
---

Dependency management in Python has evolved significantly over the past 15+ years. What started as a simple requirements.txt file has grown into a rich ecosystem of tools like pip-compile, Poetry, and containerized deployments with Docker.

### Pip, requirements.txt, virtualenv

After the deprecation of easy_install, pip became the package installer for Python. The common workflow to build your list of dependencies for other contributers and other machines was to start a virtual environment, pip install the requirements, then use pip to generate the requirements.txt, and looked something like this:

```bash
virtualenv venv
source venv/bin/activate
pip install flask requests sqlalchemy
pip freeze > requirements.txt
```

This generated a requirements.txt file such as:

```
Flask==2.3.2
Werkzeug==2.3.6
Jinja2==3.1.2
requests==2.31.0
...
```

Then other developers or developer environments could install from the requirements.txt:

```bash
source venv/bin/activate
pip install -r requirements.txt
```

But as dependencies needing updating, this failed to account for what happened when the dependencies of your dependencies changed. It could be difficult to realize why specific dependencies were being included, if you still needed them, and if their versions were going to be compatible with the versions of other dependencies that you needed.


### requirements.in, pip-compile

To solve the “frozen transitive dependency soup” problem, pip-tools introduced pip-compile. Instead of freezing your entire environment, you define your direct dependencies (the ones you really intended to have) in a requirements.in file:

```
flask
sqlalchemy
requests
```

Then you compile it from the command line:

```bash
pip-compile requirements.in
```

This generates a fully pinned requirements.txt, including the explanation of why (directly from requirements.in or a dependency):

```
#
# This file is autogenerated by pip-compile with Python 3.11
# by the following command:
#
#    pip-compile requirements.in
#
Flask==2.3.2
    # via -r requirements.in
Werkzeug==2.3.6
    # via flask
Jinja2==3.1.2
    # via flask
...
```

You still needed the previous use of virtualenv... or one of its evolutions. Because it was changing too during this time.

### Virtual environments

Python 3.3 introduced built-in venv for virtual environments:

```bash
python -m venv .venv
source .venv/bin/activate
```

Virtual environments for each project was considered standard best practices to isolate the dependencies and to make reproducible environments. Virtual environments could also be used to set the version of python being used, usually requiring developers to communicate such as adding it to the README with a copy and paste venv setup.

### Packaging with Poetry

Poetry not only unifies dependency management with virtual environment handling, but is also used for packaging and publishing. If you don't need packaging and publishing, you can set package-mode to false and use it to replace requirements.text and venv. You can also define your requirements for the python version. Instead of requirements.txt, Poetry uses pyproject.toml. The intentional dependencies (similar to requirements.in) are added to the pyproject.toml and then Poetry compiles a lock file with not only information needed to install but also details about every package needed such as the description and the python versions supported by that package at that version. It's beautiful, I think.

### Where are we now?

I still see a lot of manually managed requirements.txt, compiled requirements.txt, and Poetry. I think it is great to be familiar with all of them so that you can appreciate why that was chosen and anticipate the problems you may encounter. Personally, I am done manually maintaining requirements.txt. I have gone through so many iterations playing whack-a-mole when it comes time to update versions, but that should be the easy part. If you are building a package, choosing Poetry is a much easier sell. Being that I'm a web developer, I've been using containers. But that doesn't influence my decision because either requirement.txt or the Poetry files can be used. I do like the developer experience of using Poetry. I find it is very helpful with telling me what to do from the command line when I need to update the lock file or why an error occurred. I wrote a small Flask app to manage my posts for this blog, save the markdown files, and generate static pages for hosting with GitHub Pages. For that I decided to use Poetry.