<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Python Dependency Management -- History and Evolution - HHDevConsulting</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">

</head>
<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="/index.html">HousewifeHacker Blog</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#nav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="nav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="/index.html">Home</a></li>
                    <li class="nav-item"><a class="nav-link" href="/about.html">About</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <main class="container my-4">
        
<article>
    <h1>Python Dependency Management -- History and Evolution</h1>
    <small>2026-02-27</small>
    <hr>
    <p>Dependency management in Python has evolved significantly over the past 15+ years. What started as a simple requirements.txt file has grown into a rich ecosystem of tools like pip-compile, Poetry, and containerized deployments with Docker.</p>
<h3>Pip, requirements.txt, virtualenv</h3>
<p>After the deprecation of easy_install, pip became the package installer for Python. The common workflow to build your list of dependencies for other contributers and other machines was to start a virtual environment, pip install the requirements, then use pip to generate the requirements.txt, and looked something like this:</p>
<div class="codehilite"><pre><span></span><code>virtualenv<span class="w"> </span>venv
<span class="nb">source</span><span class="w"> </span>venv/bin/activate
pip<span class="w"> </span>install<span class="w"> </span>flask<span class="w"> </span>requests<span class="w"> </span>sqlalchemy
pip<span class="w"> </span>freeze<span class="w"> </span>&gt;<span class="w"> </span>requirements.txt
</code></pre></div>

<p>This generated a requirements.txt file such as:</p>
<div class="codehilite"><pre><span></span><code>Flask==2.3.2
Werkzeug==2.3.6
Jinja2==3.1.2
requests==2.31.0
...
</code></pre></div>

<p>Then other developers or developer environments could install from the requirements.txt:</p>
<div class="codehilite"><pre><span></span><code><span class="nb">source</span><span class="w"> </span>venv/bin/activate
pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
</code></pre></div>

<p>But as dependencies needing updating, this failed to account for what happened when the dependencies of your dependencies changed. It could be difficult to realize why specific dependencies were being included, if you still needed them, and if their versions were going to be compatible with the versions of other dependencies that you needed.</p>
<h3>requirements.in, pip-compile</h3>
<p>To solve the “frozen transitive dependency soup” problem, pip-tools introduced pip-compile. Instead of freezing your entire environment, you define your direct dependencies (the ones you really intended to have) in a requirements.in file:</p>
<div class="codehilite"><pre><span></span><code>flask
sqlalchemy
requests
</code></pre></div>

<p>Then you compile it from the command line:</p>
<div class="codehilite"><pre><span></span><code>pip-compile<span class="w"> </span>requirements.in
</code></pre></div>

<p>This generates a fully pinned requirements.txt, including the explanation of why (directly from requirements.in or a dependency):</p>
<div class="codehilite"><pre><span></span><code>#
# This file is autogenerated by pip-compile with Python 3.11
# by the following command:
#
#    pip-compile requirements.in
#
Flask==2.3.2
    # via -r requirements.in
Werkzeug==2.3.6
    # via flask
Jinja2==3.1.2
    # via flask
...
</code></pre></div>

<p>You still needed the previous use of virtualenv... or one of its evolutions. Because it was changing too during this time.</p>
<h3>Virtual environments</h3>
<p>Python 3.3 introduced built-in venv for virtual environments:</p>
<div class="codehilite"><pre><span></span><code>python<span class="w"> </span>-m<span class="w"> </span>venv<span class="w"> </span>.venv
<span class="nb">source</span><span class="w"> </span>.venv/bin/activate
</code></pre></div>

<p>Virtual environments for each project was considered standard best practices to isolate the dependencies and to make reproducible environments. Virtual environments could also be used to set the version of python being used, usually requiring developers to communicate such as adding it to the README with a copy and paste venv setup.</p>
<h3>Packaging with Poetry</h3>
<p>Poetry not only unifies dependency management with virtual environment handling, but is also used for packaging and publishing. If you don't need packaging and publishing, you can set package-mode to false and use it to replace requirements.text and venv. You can also define your requirements for the python version. Instead of requirements.txt, Poetry uses pyproject.toml. The intentional dependencies (similar to requirements.in) are added to the pyproject.toml and then Poetry compiles a lock file with not only information needed to install but also details about every package needed such as the description and the python versions supported by that package at that version. It's beautiful, I think.</p>
<h3>Where are we now?</h3>
<p>I still see a lot of manually managed requirements.txt, compiled requirements.txt, and Poetry. I think it is great to be familiar with all of them so that you can appreciate why that was chosen and anticipate the problems you may encounter. Personally, I am done manually maintaining requirements.txt. I have gone through so many iterations playing whack-a-mole when it comes time to update versions, but that should be the easy part. If you are building a package, choosing Poetry is a much easier sell. Being that I'm a web developer, I've been using containers. But that doesn't influence my decision because either requirement.txt or the Poetry files can be used. I do like the developer experience of using Poetry. I find it is very helpful with telling me what to do from the command line when I need to update the lock file or why an error occurred. I wrote a small Flask app to manage my posts for this blog, save the markdown files, and generate static pages for hosting with GitHub Pages. For that I decided to use Poetry.</p>
</article>

    </main>

    <footer class="border-top py-3 mt-4">
        <div class="container text-muted small">
            &copy; 2026 Jessica Anderson
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>